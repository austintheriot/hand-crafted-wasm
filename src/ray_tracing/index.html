<!DOCTYPE html>

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ray Tracing</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      position: "relative";
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
    }

    canvas {
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      touch-action: none;
      cursor: move;

      /* for debugging */
      background-color: lightpink;

      /* default is to smooth edges of pixels on canvas */
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      z-index: 0;
    }

    /* replace with @media (pointer: none) */
    @media (max-width: 500px) {
      .touch-controller {
        position: fixed;
        bottom: 2rem;
        left: 0;
        width: 100vw;
        height: 10rem;
        z-index: 1;
        display: flex;
        justify-content: space-evenly;
        align-items: center;
      }

      .left-stick,
      .right-stick {
        width: 160px;
        height: 160px;
        min-width: 160px;
        min-height: 160px;
        background-color: transparent;
        border: 3px solid #ffffffaa;
        border-radius: 50%;
        position: relative;
      }

      .left-thumb-location-indicator,
      .right-thumb-location-indicator {
        display: block;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background-color: transparent;
        border: 1px solid #ffffff77;
        touch-action: none;
      }
    }

    /* replace with @media (pointer: fine) or (pointer: coarse)  */
    @media (min-width: 501px) {
      .touch-controller {
        display: none;
      }
    }
  </style>
  <!-- Hack: enables cross-origin-isolation through a service worker -->
  <!-- see https://github.com/gzuidhof/coi-serviceworker -->
  <script src="coi-serviceworker.min.js"></script>
</head>

<body>
  <canvas></canvas>
  <section class="touch-controller">
    <button class="left-stick" type="button">
      <span class="left-thumb-location-indicator"></span>
    </button>
    <button class="right-stick" type="button">
      <span class="right-thumb-location-indicator"></span>
    </button>
  </section>
  <script>
    window.coi = {
      // // A function that is run to decide whether to register the SW or not.
      // You could for instance make this return a value based on whether you actually need to be cross origin isolated or not.
      shouldRegister: () => true,
      // If this function returns true, any existing service worker will be deregistered (and nothing else will happen).
      shouldDeregister: () => false,
      // A function that is run to decide whether to use "Cross-Origin-Embedder-Policy: credentialless" or not.
      // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy#browser_compatibility
      coepCredentialless: () =>
        !(navigator.userAgent.indexOf("CriOS") > -1 || !window.chrome),
      // Override this if you want to prompt the user and do reload at your own leisure. Maybe show the user a message saying:
      // "Click OK to refresh the page to enable <...>"
      doReload: () => window.location.reload(),
      // Set to true if you don't want coi to log anything to the console.
      quiet: false,
    };

    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const leftStickButton = document.querySelector(".left-stick");
    const leftThumbLocationIndicatorButton = document.querySelector(
      ".left-thumb-location-indicator"
    );
    const rightStickButton = document.querySelector(".right-stick");
    const rightThumbLocationIndicatorButton = document.querySelector(
      ".right-thumb-location-indicator"
    );

    const worker = new Worker("worker.js");
    console.log({ worker });

    const sharedMemory = new WebAssembly.Memory({
      shared: true,
      initial: 2000,
      maximum: 2000,
    });

    const array = new Uint8Array(sharedMemory.buffer);
    const value = Atomics.load(array, 0);
    console.log("First value from main thread initialization: ", {
      sharedMemory,
      array,
      value,
    });

    worker.postMessage({
      type: "start",
      windowInnerWidth: window.innerWidth,
      windowInnerHeight: window.innerHeight,
      sharedMemory,
    });

    const render = async ({
      canvasDataPtr,
      canvasDataLen,
      canvasWidth,
      canvasHeight,
    }) => {
      // sync viewport with webassembly canvas
      if (canvas.width != canvasWidth) {
        canvas.width = canvasWidth;
      }
      if (canvas.height != canvasHeight) {
        canvas.height = canvasHeight;
      }

      // get reference to canvas image data in wasm's linear memory
      const canvasData = new Uint8Array(
        sharedMemory.buffer,
        canvasDataPtr,
        canvasDataLen
      );

      // transform wasm linear memory to image data
      const imageData = ctx.createImageData(canvasWidth, canvasHeight);
      imageData.data.set(canvasData);

      console.log({
        imageData,
        canvasDataFirstValue: new Uint8Array(canvasData.buffer)[0],
      });

      // load image data onto canvas
      ctx.putImageData(imageData, 0, 0);
    };

    worker.onmessage = (e) => {
      console.log("message received on main thread: ", { e });
      const { type } = e.data;

      switch (type) {
        case "renderComplete":
          render(e.data);
          break;
      }
    };
    worker.onerror = (e) => {
      console.log("error in worker: ", { e, worker });
    };
    worker.onmessageerror = (e) => {
      console.log("message error on main thread: ", { e, worker });
    };
  </script>
</body>
