<!DOCTYPE html>

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <style>
    body {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      margin: 0;
      position: "relative";
      background-color: black;
      overflow: hidden;
    }

    canvas {
      width: calc(100% + 1rem);
      height: calc(100% + 1rem);
      object-fit: contain;
      touch-action: none;
      /* for debugging */
      background-color: black;

      /* default is to smooth edges of pixels on canvas */
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    button {
      margin: 2rem;
      width: fit-content;
    }
  </style>
</head>

<body>
  <canvas></canvas>
  <script>
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");

    // update canvas dimensions from within wasm
    const updateCanvasDimensions = (width, height) => {
      canvas.width = width;
      canvas.height = height;
    };

    const throwError = (errorCode) => {
      console.error("Error occurred during execution:", { errorCode });
    };

    Promise.all([
      fetch("../perlin_noise/perlin_noise_optimized.wasm"),
      fetch("./ray_tracing_optimized.wasm"),
    ])
      .then(([res1, res2]) =>
        Promise.all([res1.arrayBuffer(), res2.arrayBuffer()])
      )
      .then(async ([bytes1, bytes2]) => {
        // perlin noise
        const {
          instance: {
            exports: { perlin_noise },
          },
        } = await WebAssembly.instantiate(bytes1, { console, Math });

        // ray_tracing
        return WebAssembly.instantiate(bytes2, {
          noise: { perlin_noise },
          Math,
          console,
          canvas: { updateCanvasDimensions },
          error: { throw: throwError },
        });
      })
      .then(({ instance: { exports: wasm } }) => {
        window.addEventListener("resize", (e) => {
          wasm.sync_viewport(window.innerWidth, window.innerHeight);
        });

        wasm.init(window.innerWidth, window.innerHeight);

        const render = () => {
          if (wasm.canvas_width.value && wasm.canvas_height.value) {
            // get reference to canvas image data in wasm's linear memory
            const canvasData = new Uint8Array(
              wasm.memory.buffer,
              0,
              wasm.canvas_width.value *
                wasm.canvas_height.value *
                wasm.bytes_per_pixel.value
            );

            // transform wasm linear memory to image data
            const imageData = ctx.createImageData(
              wasm.canvas_width.value,
              wasm.canvas_height.value
            );
            imageData.data.set(canvasData);

            // load image data onto canvas
            ctx.putImageData(imageData, 0, 0);
          }
        };

        wasm.tick();
        render();

        // // animate
        // (async function animate() {
        //   wasm.tick();
        //   render();
        //   requestAnimationFrame(animate);
        // })();
      })
      .catch((e) => console.error(e));
  </script>
</body>
