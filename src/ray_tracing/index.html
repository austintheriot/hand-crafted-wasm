<!DOCTYPE html>

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ray Tracing</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      position: "relative";
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
    }

    canvas {
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      touch-action: none;

      /* for debugging */
      background-color: lightpink;

      /* default is to smooth edges of pixels on canvas */
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      z-index: 0;
    }

    /* replace with @media (pointer: none) */
    @media (max-width: 500px) {
      .touch-controller {
        position: fixed;
        bottom: 2rem;
        left: 0;
        width: 100vw;
        height: 10rem;
        z-index: 1;
        display: flex;
        justify-content: space-evenly;
        align-items: center;
      }

      .left-stick,
      .right-stick {
        width: 160px;
        height: 160px;
        min-width: 160px;
        min-height: 160px;
        background-color: transparent;
        border: 3px solid #ffffffaa;
        border-radius: 50%;
        position: relative;
      }

      .left-thumb-location-indicator,
      .right-thumb-location-indicator {
        display: block;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background-color: transparent;
        border: 1px solid #ffffff77;
        touch-action: none;
      }
    }

    /* replace with @media (pointer: fine) or (pointer: coarse)  */
    @media (min-width: 501px) {
      .touch-controller {
        display: none;
      }
    }
  </style>
</head>

<body>
  <canvas></canvas>
  <section class="touch-controller">
    <button class="left-stick" type="button">
      <span class="left-thumb-location-indicator"></span>
    </button>
    <button class="right-stick" type="button">
      <span class="right-thumb-location-indicator"></span>
    </button>
  </section>
  <script>
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const leftStickButton = document.querySelector(".left-stick");
    const leftThumbLocationIndicatorButton = document.querySelector(
      ".left-thumb-location-indicator"
    );
    const rightStickButton = document.querySelector(".right-stick");
    const rightThumbLocationIndicatorButton = document.querySelector(
      ".right-thumb-location-indicator"
    );

    // update canvas dimensions from within wasm
    const updateCanvasDimensions = (width, height) => {
      canvas.width = width;
      canvas.height = height;
    };

    const throwError = (errorCode) => {
      console.error("Error occurred during execution:", { errorCode });
    };

    Promise.all([
      fetch("../perlin_noise/perlin_noise_optimized.wasm"),
      fetch("./ray_tracing_optimized.wasm"),
    ])
      .then(([res1, res2]) =>
        Promise.all([res1.arrayBuffer(), res2.arrayBuffer()])
      )
      .then(async ([bytes1, bytes2]) => {
        // perlin noise
        const {
          instance: {
            exports: { perlin_noise },
          },
        } = await WebAssembly.instantiate(bytes1, { console, Math });

        // ray_tracing
        return WebAssembly.instantiate(bytes2, {
          noise: { perlin_noise },
          Math,
          console,
          canvas: { updateCanvasDimensions },
          error: { throw: throwError },
          Date,
        });
      })
      .then(({ instance: { exports: wasm } }) => {
        wasm.init(window.innerWidth, window.innerHeight);

        console.log({ wasm })

        const render = () => {
          if (wasm.canvas_width.value && wasm.canvas_height.value) {
            // get reference to canvas image data in wasm's linear memory
            const canvasData = new Uint8Array(
              wasm.memory.buffer,
              wasm.canvas_data_ptr.value,
              wasm.canvas_data_len.value
            );

            // transform wasm linear memory to image data
            const imageData = ctx.createImageData(
              wasm.canvas_width.value,
              wasm.canvas_height.value
            );
            imageData.data.set(canvasData);

            // load image data onto canvas
            ctx.putImageData(imageData, 0, 0);
          }
        };

        window.addEventListener("resize", (e) => {
          wasm.sync_viewport(window.innerWidth, window.innerHeight);
        });

        const makeHandleTouchMove = (side) => (e) => {
          const stickButton =
            side === "left" ? leftStickButton : rightStickButton;
          const thumbIndicator =
            side === "left"
              ? leftThumbLocationIndicatorButton
              : rightThumbLocationIndicatorButton;
          const {
            width,
            height,
            x: elementX,
            y: elementY,
          } = stickButton.getBoundingClientRect();
          const [{ pageX, pageY }] = e.targetTouches;
          const windowWidth = window.innerWidth;
          const windowHeight = window.innerHeight;
          const elementCenterX = elementX + width / 2;
          const elementCenterY = elementY + height / 2;
          const distFromCenterX = pageX - elementCenterX;
          const distFromCenterY = pageY - elementCenterY;

          const STICK_SENSITIVITY = 2;

          // vector from the center of the button to the current element,
          // as a percentage of the element's width / height--
          // if you want non-limited values (i.e. dragging your finger outside
          // of the element itself is considered a stronger vector), then you
          // should use this value
          const px = (distFromCenterX / width) * STICK_SENSITIVITY;
          const py = (distFromCenterY / height) * STICK_SENSITIVITY;

          // get both numbers in range -1->1 going from left-to-right and bottom-to-top
          const BORDER_OFFSET = 0.1;
          const vectorLength = Math.sqrt(px ** 2 + py ** 2) + BORDER_OFFSET;

          // convert [px, py] into a unit vector to keep it in it's containing circle
          // (to make it act similarly to a joystick)
          const unitX = px / vectorLength;
          const unitY = py / vectorLength;

          /** Take whichever is smaller: the unit vector one or the original */
          const smallestX = vectorLength < 1 ? px : unitX;
          const smallestY = vectorLength < 1 ? py : unitY;

          // map from -1->1 to -1->0 -> -100 -> 5
          const cssX = (smallestX * 0.5 - 0.5) * 100;
          const cssY = (smallestY * 0.5 - 0.5) * 100;

          // y must be inverted to match wasm memory layout
          // (since web uses y=0 as being at the TOP of the window)
          wasm[`${side}_stick_y_position`].value = -py;
          wasm[`${side}_stick_x_position`].value = px;

          thumbIndicator.style.setProperty(
            "transform",
            `translate(${cssX}%, ${cssY}%)`
          );
        };

        const makeHandleTouchEnd = (side) => () => {
          const thumbIndicator =
            side === "left"
              ? leftThumbLocationIndicatorButton
              : rightThumbLocationIndicatorButton;

          wasm[`${side}_stick_y_position`].value = 0;
          wasm[`${side}_stick_x_position`].value = 0;

          thumbIndicator.style.setProperty(
            "transform",
            `translate(-50%, -50%)`
          );
        };

        const leftHandleTouchMove = makeHandleTouchMove("left");
        leftStickButton.addEventListener("touchstart", leftHandleTouchMove);
        leftStickButton.addEventListener("touchmove", leftHandleTouchMove);
        leftStickButton.addEventListener(
          "touchend",
          makeHandleTouchEnd("left")
        );
        leftStickButton.addEventListener("click", (e) => e.preventDefault());

        const rightHandleTouchMove = makeHandleTouchMove("right");
        rightStickButton.addEventListener("touchstart", rightHandleTouchMove);
        rightStickButton.addEventListener("touchmove", rightHandleTouchMove);
        rightStickButton.addEventListener(
          "touchend",
          makeHandleTouchEnd("right")
        );
        rightStickButton.addEventListener("click", (e) => e.preventDefault());

        const keyDownState = {};
        const makeKeyHandler = (handlerType) => (e) => {
          const booleanValue = handlerType === "down";
          if (keyDownState[e.key] === booleanValue) return;

          const constant = handlerType === "down" ? 1 : -1;
          switch (e.key) {
            case "w":
              wasm.left_stick_y_position.value += constant;
              break;
            case "s":
              wasm.left_stick_y_position.value -= constant;
              break;
            case "d":
              wasm.left_stick_x_position.value += constant;
              break;
            case "a":
              wasm.left_stick_x_position.value -= constant;
              break;
            case " ":
              wasm.left_stick_z_position.value += constant;
              break;
            case "Shift":
              wasm.left_stick_z_position.value -= constant;
              break;
          }

          keyDownState[e.key] = booleanValue;
        };
        window.addEventListener("keydown", makeKeyHandler("down"));
        window.addEventListener("keyup", makeKeyHandler("up"));

        const TOTAL_ITERATIONS = Infinity;
        let currentIteration = 0;

        // animate
        (async function animate() {
          if (currentIteration >= TOTAL_ITERATIONS) {
            return;
          } else {
            currentIteration += 1;
          }

          wasm.tick();
          render();
          requestAnimationFrame(animate);
        })();
      })
      .catch((e) => console.error(e));
  </script>
</body>
